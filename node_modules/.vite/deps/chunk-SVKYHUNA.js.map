{
  "version": 3,
  "sources": ["../../ol/math.js", "../../ol/string.js", "../../ol/coordinate.js"],
  "sourcesContent": ["/**\n * @module ol/math\n */\n\n/**\n * Takes a number and clamps it to within the provided bounds.\n * @param {number} value The input number.\n * @param {number} min The minimum value to return.\n * @param {number} max The maximum value to return.\n * @return {number} The input number if it is within bounds, or the nearest\n *     number within the bounds.\n */\nexport function clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Returns the square of the closest distance between the point (x, y) and the\n * line segment (x1, y1) to (x2, y2).\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  if (dx !== 0 || dy !== 0) {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x1 = x2;\n      y1 = y2;\n    } else if (t > 0) {\n      x1 += dx * t;\n      y1 += dy * t;\n    }\n  }\n  return squaredDistance(x, y, x1, y1);\n}\n\n/**\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredDistance(x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  return dx * dx + dy * dy;\n}\n\n/**\n * Solves system of linear equations using Gaussian elimination method.\n *\n * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\n *                                     in row-major order.\n * @return {Array<number>} The resulting vector.\n */\nexport function solveLinearSystem(mat) {\n  const n = mat.length;\n\n  for (let i = 0; i < n; i++) {\n    // Find max in the i-th column (ignoring i - 1 first rows)\n    let maxRow = i;\n    let maxEl = Math.abs(mat[i][i]);\n    for (let r = i + 1; r < n; r++) {\n      const absValue = Math.abs(mat[r][i]);\n      if (absValue > maxEl) {\n        maxEl = absValue;\n        maxRow = r;\n      }\n    }\n\n    if (maxEl === 0) {\n      return null; // matrix is singular\n    }\n\n    // Swap max row with i-th (current) row\n    const tmp = mat[maxRow];\n    mat[maxRow] = mat[i];\n    mat[i] = tmp;\n\n    // Subtract the i-th row to make all the remaining rows 0 in the i-th column\n    for (let j = i + 1; j < n; j++) {\n      const coef = -mat[j][i] / mat[i][i];\n      for (let k = i; k < n + 1; k++) {\n        if (i == k) {\n          mat[j][k] = 0;\n        } else {\n          mat[j][k] += coef * mat[i][k];\n        }\n      }\n    }\n  }\n\n  // Solve Ax=b for upper triangular matrix A (mat)\n  const x = new Array(n);\n  for (let l = n - 1; l >= 0; l--) {\n    x[l] = mat[l][n] / mat[l][l];\n    for (let m = l - 1; m >= 0; m--) {\n      mat[m][n] -= mat[m][l] * x[l];\n    }\n  }\n  return x;\n}\n\n/**\n * Converts radians to to degrees.\n *\n * @param {number} angleInRadians Angle in radians.\n * @return {number} Angle in degrees.\n */\nexport function toDegrees(angleInRadians) {\n  return (angleInRadians * 180) / Math.PI;\n}\n\n/**\n * Converts degrees to radians.\n *\n * @param {number} angleInDegrees Angle in degrees.\n * @return {number} Angle in radians.\n */\nexport function toRadians(angleInDegrees) {\n  return (angleInDegrees * Math.PI) / 180;\n}\n\n/**\n * Returns the modulo of a / b, depending on the sign of b.\n *\n * @param {number} a Dividend.\n * @param {number} b Divisor.\n * @return {number} Modulo.\n */\nexport function modulo(a, b) {\n  const r = a % b;\n  return r * b < 0 ? r + b : r;\n}\n\n/**\n * Calculates the linearly interpolated value of x between a and b.\n *\n * @param {number} a Number\n * @param {number} b Number\n * @param {number} x Value to be interpolated.\n * @return {number} Interpolated value.\n */\nexport function lerp(a, b, x) {\n  return a + x * (b - a);\n}\n\n/**\n * Returns a number with a limited number of decimal digits.\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The input number with a limited number of decimal digits.\n */\nexport function toFixed(n, decimals) {\n  const factor = Math.pow(10, decimals);\n  return Math.round(n * factor) / factor;\n}\n\n/**\n * Rounds a number to the nearest integer value considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The nearest integer.\n */\nexport function round(n, decimals) {\n  return Math.round(toFixed(n, decimals));\n}\n\n/**\n * Rounds a number to the next smaller integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next smaller integer.\n */\nexport function floor(n, decimals) {\n  return Math.floor(toFixed(n, decimals));\n}\n\n/**\n * Rounds a number to the next bigger integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next bigger integer.\n */\nexport function ceil(n, decimals) {\n  return Math.ceil(toFixed(n, decimals));\n}\n", "/**\n * @module ol/string\n */\n\n/**\n * @param {number} number Number to be formatted\n * @param {number} width The desired width\n * @param {number} [precision] Precision of the output string (i.e. number of decimal places)\n * @return {string} Formatted string\n */\nexport function padNumber(number, width, precision) {\n  const numberString =\n    precision !== undefined ? number.toFixed(precision) : '' + number;\n  let decimal = numberString.indexOf('.');\n  decimal = decimal === -1 ? numberString.length : decimal;\n  return decimal > width\n    ? numberString\n    : new Array(1 + width - decimal).join('0') + numberString;\n}\n\n/**\n * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\n * @param {string|number} v1 First version\n * @param {string|number} v2 Second version\n * @return {number} Value\n */\nexport function compareVersions(v1, v2) {\n  const s1 = ('' + v1).split('.');\n  const s2 = ('' + v2).split('.');\n\n  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {\n    const n1 = parseInt(s1[i] || '0', 10);\n    const n2 = parseInt(s2[i] || '0', 10);\n\n    if (n1 > n2) {\n      return 1;\n    }\n    if (n2 > n1) {\n      return -1;\n    }\n  }\n\n  return 0;\n}\n", "/**\n * @module ol/coordinate\n */\nimport {getWidth} from './extent.js';\nimport {modulo, toFixed} from './math.js';\nimport {padNumber} from './string.js';\n\n/**\n * An array of numbers representing an xy coordinate. Example: `[16, 48]`.\n * @typedef {Array<number>} Coordinate\n * @api\n */\n\n/**\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\n * transforms it into a `{string}`.\n *\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\n * @api\n */\n\n/**\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {add} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     add(coord, [-2, 4]);\n *     // coord is now [5.85, 51.983333]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {Coordinate} delta Delta.\n * @return {Coordinate} The input coordinate adjusted by\n * the given delta.\n * @api\n */\nexport function add(coordinate, delta) {\n  coordinate[0] += +delta[0];\n  coordinate[1] += +delta[1];\n  return coordinate;\n}\n\n/**\n * Calculates the point closest to the passed coordinate on the passed circle.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\n * @return {Coordinate} Closest point on the circumference.\n */\nexport function closestOnCircle(coordinate, circle) {\n  const r = circle.getRadius();\n  const center = circle.getCenter();\n  const x0 = center[0];\n  const y0 = center[1];\n  const x1 = coordinate[0];\n  const y1 = coordinate[1];\n\n  let dx = x1 - x0;\n  const dy = y1 - y0;\n  if (dx === 0 && dy === 0) {\n    dx = 1;\n  }\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  const x = x0 + (r * dx) / d;\n  const y = y0 + (r * dy) / d;\n\n  return [x, y];\n}\n\n/**\n * Calculates the point closest to the passed coordinate on the passed segment.\n * This is the foot of the perpendicular of the coordinate to the segment when\n * the foot is on the segment, or the closest segment coordinate when the foot\n * is outside the segment.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {Array<Coordinate>} segment The two coordinates\n * of the segment.\n * @return {Coordinate} The foot of the perpendicular of\n * the coordinate to the segment.\n */\nexport function closestOnSegment(coordinate, segment) {\n  const x0 = coordinate[0];\n  const y0 = coordinate[1];\n  const start = segment[0];\n  const end = segment[1];\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const along =\n    dx === 0 && dy === 0\n      ? 0\n      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n  let x, y;\n  if (along <= 0) {\n    x = x1;\n    y = y1;\n  } else if (along >= 1) {\n    x = x2;\n    y = y2;\n  } else {\n    x = x1 + along * dx;\n    y = y1 + along * dy;\n  }\n  return [x, y];\n}\n\n/**\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\n * used to format\n * a {Coordinate} to a string.\n *\n * Example without specifying the fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY();\n *     const out = stringifyFunc(coord);\n *     // out is now '8, 48'\n *\n * Example with explicitly specifying 2 fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY(2);\n *     const out = stringifyFunc(coord);\n *     // out is now '7.85, 47.98'\n *\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {CoordinateFormat} Coordinate format.\n * @api\n */\nexport function createStringXY(fractionDigits) {\n  return (\n    /**\n     * @param {Coordinate} coordinate Coordinate.\n     * @return {string} String XY.\n     */\n    function (coordinate) {\n      return toStringXY(coordinate, fractionDigits);\n    }\n  );\n}\n\n/**\n * @param {string} hemispheres Hemispheres.\n * @param {number} degrees Degrees.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} String.\n */\nexport function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {\n  const normalizedDegrees = modulo(degrees + 180, 360) - 180;\n  const x = Math.abs(3600 * normalizedDegrees);\n  const decimals = fractionDigits || 0;\n\n  let deg = Math.floor(x / 3600);\n  let min = Math.floor((x - deg * 3600) / 60);\n  let sec = toFixed(x - deg * 3600 - min * 60, decimals);\n\n  if (sec >= 60) {\n    sec = 0;\n    min += 1;\n  }\n\n  if (min >= 60) {\n    min = 0;\n    deg += 1;\n  }\n\n  let hdms = deg + '\\u00b0';\n  if (min !== 0 || sec !== 0) {\n    hdms += ' ' + padNumber(min, 2) + '\\u2032';\n  }\n  if (sec !== 0) {\n    hdms += ' ' + padNumber(sec, 2, decimals) + '\\u2033';\n  }\n  if (normalizedDegrees !== 0) {\n    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);\n  }\n\n  return hdms;\n}\n\n/**\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\n * using the given string template. The strings `{x}` and `{y}` in the template\n * will be replaced with the first and second coordinate values respectively.\n *\n * Example without specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template);\n *     // out is now 'Coordinate is (8|48).'\n *\n * Example explicitly specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template, 2);\n *     // out is now 'Coordinate is (7.85|47.98).'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {string} template A template string with `{x}` and `{y}` placeholders\n *     that will be replaced by first and second coordinate values.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Formatted coordinate.\n * @api\n */\nexport function format(coordinate, template, fractionDigits) {\n  if (coordinate) {\n    return template\n      .replace('{x}', coordinate[0].toFixed(fractionDigits))\n      .replace('{y}', coordinate[1].toFixed(fractionDigits));\n  }\n  return '';\n}\n\n/**\n * @param {Coordinate} coordinate1 First coordinate.\n * @param {Coordinate} coordinate2 Second coordinate.\n * @return {boolean} The two coordinates are equal.\n */\nexport function equals(coordinate1, coordinate2) {\n  let equals = true;\n  for (let i = coordinate1.length - 1; i >= 0; --i) {\n    if (coordinate1[i] != coordinate2[i]) {\n      equals = false;\n      break;\n    }\n  }\n  return equals;\n}\n\n/**\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n * returned by the function.\n *\n * Example:\n *\n *     import {rotate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const rotateRadians = Math.PI / 2; // 90 degrees\n *     rotate(coord, rotateRadians);\n *     // coord is now [-47.983333, 7.85]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} angle Angle in radian.\n * @return {Coordinate} Coordinate.\n * @api\n */\nexport function rotate(coordinate, angle) {\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  coordinate[0] = x;\n  coordinate[1] = y;\n  return coordinate;\n}\n\n/**\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {scale as scaleCoordinate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const scale = 1.2;\n *     scaleCoordinate(coord, scale);\n *     // coord is now [9.42, 57.5799996]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} scale Scale factor.\n * @return {Coordinate} Coordinate.\n */\nexport function scale(coordinate, scale) {\n  coordinate[0] *= scale;\n  coordinate[1] *= scale;\n  return coordinate;\n}\n\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Squared distance between coord1 and coord2.\n */\nexport function squaredDistance(coord1, coord2) {\n  const dx = coord1[0] - coord2[0];\n  const dy = coord1[1] - coord2[1];\n  return dx * dx + dy * dy;\n}\n\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Distance between coord1 and coord2.\n */\nexport function distance(coord1, coord2) {\n  return Math.sqrt(squaredDistance(coord1, coord2));\n}\n\n/**\n * Calculate the squared distance from a coordinate to a line segment.\n *\n * @param {Coordinate} coordinate Coordinate of the point.\n * @param {Array<Coordinate>} segment Line segment (2\n * coordinates).\n * @return {number} Squared distance from the point to the line segment.\n */\nexport function squaredDistanceToSegment(coordinate, segment) {\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\n}\n\n/**\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\n * seconds.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord);\n *     // out is now '47\u00B0 58\u2032 60\u2033 N 7\u00B0 50\u2032 60\u2033 E'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord, 1);\n *     // out is now '47\u00B0 58\u2032 60.0\u2033 N 7\u00B0 50\u2032 60.0\u2033 E'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Hemisphere, degrees, minutes and seconds.\n * @api\n */\nexport function toStringHDMS(coordinate, fractionDigits) {\n  if (coordinate) {\n    return (\n      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +\n      ' ' +\n      degreesToStringHDMS('EW', coordinate[0], fractionDigits)\n    );\n  }\n  return '';\n}\n\n/**\n * Format a coordinate as a comma delimited string.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord);\n *     // out is now '8, 48'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord, 1);\n *     // out is now '7.8, 48.0'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} XY.\n * @api\n */\nexport function toStringXY(coordinate, fractionDigits) {\n  return format(coordinate, '{x}, {y}', fractionDigits);\n}\n\n/**\n * Modifies the provided coordinate in-place to be within the real world\n * extent. The lower projection extent boundary is inclusive, the upper one\n * exclusive.\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {Coordinate} The coordinate within the real world extent.\n */\nexport function wrapX(coordinate, projection) {\n  if (projection.canWrapX()) {\n    const worldWidth = getWidth(projection.getExtent());\n    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);\n    if (worldsAway) {\n      coordinate[0] -= worldsAway * worldWidth;\n    }\n  }\n  return coordinate;\n}\n/**\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {number} [sourceExtentWidth] Width of the source extent.\n * @return {number} Offset in world widths.\n */\nexport function getWorldsAway(coordinate, projection, sourceExtentWidth) {\n  const projectionExtent = projection.getExtent();\n  let worldsAway = 0;\n  if (\n    projection.canWrapX() &&\n    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])\n  ) {\n    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);\n    worldsAway = Math.floor(\n      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth\n    );\n  }\n  return worldsAway;\n}\n"],
  "mappings": ";;;;;AAYO,SAAS,MAAM,OAAO,KAAK,KAAK;AACrC,SAAO,KAAK,IAAI,KAAK,IAAI,OAAO,GAAG,GAAG,GAAG;AAC3C;AAaO,SAAS,uBAAuB,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI;AAC3D,QAAM,KAAK,KAAK;AAChB,QAAM,KAAK,KAAK;AAChB,MAAI,OAAO,KAAK,OAAO,GAAG;AACxB,UAAM,MAAM,IAAI,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK,KAAK,KAAK;AAC5D,QAAI,IAAI,GAAG;AACT,WAAK;AACL,WAAK;AAAA,IACP,WAAW,IAAI,GAAG;AAChB,YAAM,KAAK;AACX,YAAM,KAAK;AAAA,IACb;AAAA,EACF;AACA,SAAO,gBAAgB,GAAG,GAAG,IAAI,EAAE;AACrC;AAUO,SAAS,gBAAgB,IAAI,IAAI,IAAI,IAAI;AAC9C,QAAM,KAAK,KAAK;AAChB,QAAM,KAAK,KAAK;AAChB,SAAO,KAAK,KAAK,KAAK;AACxB;AASO,SAAS,kBAAkB,KAAK;AACrC,QAAM,IAAI,IAAI;AAEd,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAE1B,QAAI,SAAS;AACb,QAAI,QAAQ,KAAK,IAAI,IAAI,GAAG,EAAE;AAC9B,aAAS,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK;AAC9B,YAAM,WAAW,KAAK,IAAI,IAAI,GAAG,EAAE;AACnC,UAAI,WAAW,OAAO;AACpB,gBAAQ;AACR,iBAAS;AAAA,MACX;AAAA,IACF;AAEA,QAAI,UAAU,GAAG;AACf,aAAO;AAAA,IACT;AAGA,UAAM,MAAM,IAAI;AAChB,QAAI,UAAU,IAAI;AAClB,QAAI,KAAK;AAGT,aAAS,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK;AAC9B,YAAM,OAAO,CAAC,IAAI,GAAG,KAAK,IAAI,GAAG;AACjC,eAAS,IAAI,GAAG,IAAI,IAAI,GAAG,KAAK;AAC9B,YAAI,KAAK,GAAG;AACV,cAAI,GAAG,KAAK;AAAA,QACd,OAAO;AACL,cAAI,GAAG,MAAM,OAAO,IAAI,GAAG;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,QAAM,IAAI,IAAI,MAAM,CAAC;AACrB,WAAS,IAAI,IAAI,GAAG,KAAK,GAAG,KAAK;AAC/B,MAAE,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG;AAC1B,aAAS,IAAI,IAAI,GAAG,KAAK,GAAG,KAAK;AAC/B,UAAI,GAAG,MAAM,IAAI,GAAG,KAAK,EAAE;AAAA,IAC7B;AAAA,EACF;AACA,SAAO;AACT;AAQO,SAAS,UAAU,gBAAgB;AACxC,SAAQ,iBAAiB,MAAO,KAAK;AACvC;AAQO,SAAS,UAAU,gBAAgB;AACxC,SAAQ,iBAAiB,KAAK,KAAM;AACtC;AASO,SAAS,OAAO,GAAG,GAAG;AAC3B,QAAM,IAAI,IAAI;AACd,SAAO,IAAI,IAAI,IAAI,IAAI,IAAI;AAC7B;AAUO,SAAS,KAAK,GAAG,GAAG,GAAG;AAC5B,SAAO,IAAI,KAAK,IAAI;AACtB;AAQO,SAAS,QAAQ,GAAG,UAAU;AACnC,QAAM,SAAS,KAAK,IAAI,IAAI,QAAQ;AACpC,SAAO,KAAK,MAAM,IAAI,MAAM,IAAI;AAClC;AASO,SAAS,MAAM,GAAG,UAAU;AACjC,SAAO,KAAK,MAAM,QAAQ,GAAG,QAAQ,CAAC;AACxC;AASO,SAAS,MAAM,GAAG,UAAU;AACjC,SAAO,KAAK,MAAM,QAAQ,GAAG,QAAQ,CAAC;AACxC;AASO,SAAS,KAAK,GAAG,UAAU;AAChC,SAAO,KAAK,KAAK,QAAQ,GAAG,QAAQ,CAAC;AACvC;;;AC5LO,SAAS,UAAU,QAAQ,OAAO,WAAW;AAClD,QAAM,eACJ,cAAc,SAAY,OAAO,QAAQ,SAAS,IAAI,KAAK;AAC7D,MAAI,UAAU,aAAa,QAAQ,GAAG;AACtC,YAAU,YAAY,KAAK,aAAa,SAAS;AACjD,SAAO,UAAU,QACb,eACA,IAAI,MAAM,IAAI,QAAQ,OAAO,EAAE,KAAK,GAAG,IAAI;AACjD;AAQO,SAAS,gBAAgB,IAAI,IAAI;AACtC,QAAM,MAAM,KAAK,IAAI,MAAM,GAAG;AAC9B,QAAM,MAAM,KAAK,IAAI,MAAM,GAAG;AAE9B,WAAS,IAAI,GAAG,IAAI,KAAK,IAAI,GAAG,QAAQ,GAAG,MAAM,GAAG,KAAK;AACvD,UAAM,KAAK,SAAS,GAAG,MAAM,KAAK,EAAE;AACpC,UAAM,KAAK,SAAS,GAAG,MAAM,KAAK,EAAE;AAEpC,QAAI,KAAK,IAAI;AACX,aAAO;AAAA,IACT;AACA,QAAI,KAAK,IAAI;AACX,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;;;ACJO,SAAS,IAAI,YAAY,OAAO;AACrC,aAAW,MAAM,CAAC,MAAM;AACxB,aAAW,MAAM,CAAC,MAAM;AACxB,SAAO;AACT;AASO,SAAS,gBAAgB,YAAY,QAAQ;AAClD,QAAM,IAAI,OAAO,UAAU;AAC3B,QAAM,SAAS,OAAO,UAAU;AAChC,QAAM,KAAK,OAAO;AAClB,QAAM,KAAK,OAAO;AAClB,QAAM,KAAK,WAAW;AACtB,QAAM,KAAK,WAAW;AAEtB,MAAI,KAAK,KAAK;AACd,QAAM,KAAK,KAAK;AAChB,MAAI,OAAO,KAAK,OAAO,GAAG;AACxB,SAAK;AAAA,EACP;AACA,QAAM,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAErC,QAAM,IAAI,KAAM,IAAI,KAAM;AAC1B,QAAM,IAAI,KAAM,IAAI,KAAM;AAE1B,SAAO,CAAC,GAAG,CAAC;AACd;AAcO,SAAS,iBAAiB,YAAY,SAAS;AACpD,QAAM,KAAK,WAAW;AACtB,QAAM,KAAK,WAAW;AACtB,QAAM,QAAQ,QAAQ;AACtB,QAAM,MAAM,QAAQ;AACpB,QAAM,KAAK,MAAM;AACjB,QAAM,KAAK,MAAM;AACjB,QAAM,KAAK,IAAI;AACf,QAAM,KAAK,IAAI;AACf,QAAM,KAAK,KAAK;AAChB,QAAM,KAAK,KAAK;AAChB,QAAM,QACJ,OAAO,KAAK,OAAO,IACf,KACC,MAAM,KAAK,MAAM,MAAM,KAAK,QAAQ,KAAK,KAAK,KAAK,MAAM;AAChE,MAAI,GAAG;AACP,MAAI,SAAS,GAAG;AACd,QAAI;AACJ,QAAI;AAAA,EACN,WAAW,SAAS,GAAG;AACrB,QAAI;AACJ,QAAI;AAAA,EACN,OAAO;AACL,QAAI,KAAK,QAAQ;AACjB,QAAI,KAAK,QAAQ;AAAA,EACnB;AACA,SAAO,CAAC,GAAG,CAAC;AACd;AA8BO,SAAS,eAAe,gBAAgB;AAC7C,SAKE,SAAU,YAAY;AACpB,WAAO,WAAW,YAAY,cAAc;AAAA,EAC9C;AAEJ;AASO,SAAS,oBAAoB,aAAa,SAAS,gBAAgB;AACxE,QAAM,oBAAoB,OAAO,UAAU,KAAK,GAAG,IAAI;AACvD,QAAM,IAAI,KAAK,IAAI,OAAO,iBAAiB;AAC3C,QAAM,WAAW,kBAAkB;AAEnC,MAAI,MAAM,KAAK,MAAM,IAAI,IAAI;AAC7B,MAAI,MAAM,KAAK,OAAO,IAAI,MAAM,QAAQ,EAAE;AAC1C,MAAI,MAAM,QAAQ,IAAI,MAAM,OAAO,MAAM,IAAI,QAAQ;AAErD,MAAI,OAAO,IAAI;AACb,UAAM;AACN,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,IAAI;AACb,UAAM;AACN,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,MAAM;AACjB,MAAI,QAAQ,KAAK,QAAQ,GAAG;AAC1B,YAAQ,MAAM,UAAU,KAAK,CAAC,IAAI;AAAA,EACpC;AACA,MAAI,QAAQ,GAAG;AACb,YAAQ,MAAM,UAAU,KAAK,GAAG,QAAQ,IAAI;AAAA,EAC9C;AACA,MAAI,sBAAsB,GAAG;AAC3B,YAAQ,MAAM,YAAY,OAAO,oBAAoB,IAAI,IAAI,CAAC;AAAA,EAChE;AAEA,SAAO;AACT;AAiCO,SAAS,OAAO,YAAY,UAAU,gBAAgB;AAC3D,MAAI,YAAY;AACd,WAAO,SACJ,QAAQ,OAAO,WAAW,GAAG,QAAQ,cAAc,CAAC,EACpD,QAAQ,OAAO,WAAW,GAAG,QAAQ,cAAc,CAAC;AAAA,EACzD;AACA,SAAO;AACT;AAOO,SAAS,OAAO,aAAa,aAAa;AAC/C,MAAIA,UAAS;AACb,WAAS,IAAI,YAAY,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AAChD,QAAI,YAAY,MAAM,YAAY,IAAI;AACpC,MAAAA,UAAS;AACT;AAAA,IACF;AAAA,EACF;AACA,SAAOA;AACT;AAoBO,SAAS,OAAO,YAAY,OAAO;AACxC,QAAM,WAAW,KAAK,IAAI,KAAK;AAC/B,QAAM,WAAW,KAAK,IAAI,KAAK;AAC/B,QAAM,IAAI,WAAW,KAAK,WAAW,WAAW,KAAK;AACrD,QAAM,IAAI,WAAW,KAAK,WAAW,WAAW,KAAK;AACrD,aAAW,KAAK;AAChB,aAAW,KAAK;AAChB,SAAO;AACT;AAmBO,SAAS,MAAM,YAAYC,QAAO;AACvC,aAAW,MAAMA;AACjB,aAAW,MAAMA;AACjB,SAAO;AACT;AAOO,SAASC,iBAAgB,QAAQ,QAAQ;AAC9C,QAAM,KAAK,OAAO,KAAK,OAAO;AAC9B,QAAM,KAAK,OAAO,KAAK,OAAO;AAC9B,SAAO,KAAK,KAAK,KAAK;AACxB;AAOO,SAAS,SAAS,QAAQ,QAAQ;AACvC,SAAO,KAAK,KAAKA,iBAAgB,QAAQ,MAAM,CAAC;AAClD;AAUO,SAAS,yBAAyB,YAAY,SAAS;AAC5D,SAAOA,iBAAgB,YAAY,iBAAiB,YAAY,OAAO,CAAC;AAC1E;AA4BO,SAAS,aAAa,YAAY,gBAAgB;AACvD,MAAI,YAAY;AACd,WACE,oBAAoB,MAAM,WAAW,IAAI,cAAc,IACvD,MACA,oBAAoB,MAAM,WAAW,IAAI,cAAc;AAAA,EAE3D;AACA,SAAO;AACT;AA2BO,SAAS,WAAW,YAAY,gBAAgB;AACrD,SAAO,OAAO,YAAY,YAAY,cAAc;AACtD;AAWO,SAAS,MAAM,YAAY,YAAY;AAC5C,MAAI,WAAW,SAAS,GAAG;AACzB,UAAM,aAAa,SAAS,WAAW,UAAU,CAAC;AAClD,UAAM,aAAa,cAAc,YAAY,YAAY,UAAU;AACnE,QAAI,YAAY;AACd,iBAAW,MAAM,aAAa;AAAA,IAChC;AAAA,EACF;AACA,SAAO;AACT;AAOO,SAAS,cAAc,YAAY,YAAY,mBAAmB;AACvE,QAAM,mBAAmB,WAAW,UAAU;AAC9C,MAAI,aAAa;AACjB,MACE,WAAW,SAAS,MACnB,WAAW,KAAK,iBAAiB,MAAM,WAAW,KAAK,iBAAiB,KACzE;AACA,wBAAoB,qBAAqB,SAAS,gBAAgB;AAClE,iBAAa,KAAK;AAAA,OACf,WAAW,KAAK,iBAAiB,MAAM;AAAA,IAC1C;AAAA,EACF;AACA,SAAO;AACT;",
  "names": ["equals", "scale", "squaredDistance"]
}
